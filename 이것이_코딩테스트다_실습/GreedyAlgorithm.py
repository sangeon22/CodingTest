# 그리디 알고리즘(탐욕법)
# 지금 당장 좋은 것만 고르는 것
# 단순히 가장 좋아 보이는 것을 반복적으로 선택해도 최적의 해를 구할 수 있는지 검토
# 일반적인 상황에서 그리디는 최적의 해를 보장할 수 없을 때가 많음
# ex) 거스름돈 문제 => 가장 큰 단위부터 거슬러주면 됨
# 가장 큰 단위부터 거슬러 주는 것이 최적의 해를 보장하는 이유는?
# => 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문
n =1260
count = 0
arr = [500, 100, 50, 10]

for i in arr:
    count += n // i
    n %= i
print(count)

# 시간 복잡도는 O(N) => 동전의 단위 갯수로만 반복문을 돔 =>
# 동전의 총 종류에만 영향


# 어떠한 수 N이 1이 될 때 까지 다음의 두 과정 중 하나를 반복적으로 선택해 수행하려 함
# 단, 두번째 연산은 N이 K로 나누어 떨어질 때만 선택할 수 있음
# 1. N에서 1을 뺀다.
# 2. N을 K로 나눈다.
# N이 1이 될 때 까지 1번 혹은 2번의 과정을 수행해야하는 최소 횟수를 구하는 프로그램을 작성
#
# 시간 제한: 2초
#
# [입력]
# 첫째 줄에 N(2<= N <= 100000)과 K(2 <= K <= 100000)가 공백으로 구분되며 각각 자연수로 주어짐
# 이때, 입력으로 주어지는 N은 항상 K보다 크거나 같음
#
# [출력]
# 첫째 줄에 N이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야 하는 횟수의 최솟값을 출력
#
# [입력 예시]
# 3 3
# 3 1 2
# 4 1 4
# 2 2 2

# 가능하면 최대한 많이 나눈다 => 최적의 해 보장? => 1빼는 것보다 K로 나누는게 가장 빠르게 N을 줄일 수 있고, 2가지 방법을 통해 항상 1이 된다.

# (1차) 해설 안보고 혼자 풀기 => 이렇게 되면 나눠질 때까지 반복
N, K = map(int, input().split())
answer = 0
while True:
    if N % K == 0:
        N //= K
    else:
        N -= 1
    answer += 1

    if N == 1:
        break
print(answer)

# (2차) log 시간 복잡도로 해결 가능
N, K = map(int, input().split())
answer = 0
while True:
    target = (N // K) * K
    answer += (N - target)
    N = target

    if N < K:
        break

    N //= K
    answer += 1
answer += (N - 1)
print(answer)


# 각 자리가 숫자(0부터 9)로만 이루어진 문자열 S가 주어졌을 때,
# 왼쪽부터 오른쪽으로 하나씩 모든 숫자를 확인하며 숫자 사이에 'x' 혹은 '+' 연산자를 넣어 결과적으로 만들어질 수 있는 가장 큰 수를 구하는 프로그램을 작성하세요.
# 단, +보다 x를 먼저 계산하는 일반적인 방식과는 달리, 모든 연산은 왼쪽에서부터 순서대로 이루어진다고 가정합니다.
# 예를 들어 02984라는 문자열이 주어지면, 만들어질 수 있는 가장 큰 수는 ((((0+2)x9)x8)x4) = 576입니다.
# 또한 만들어질 수 있는 가장 큰 수는 항상 20억 이하의 정수가 되도록 입력이 주어집니다.
#
# 시간 제한: 1초
#
# [입력]
# 첫째 줄에 여러 개의 숫자로 구성된 하나의 문자열 S가 주어집니다.(1<=S의 길이<=20)
#
# [출력]
# 첫째 줄에 만들어질 수 있는 가장 큰 수를 출력합니다.

# (1차) 해설 안보고 혼자 풀기
s = input()
exp = '(' + s[0]

for i in range(1, len(s)):
    if s[i-1] == '0' or s[i-1] == '1':
       exp += "+" + s[i] + ")"
    else:
        exp += "*" + s[i] + ")"

exp = ((len(s) - 2) * "(") + exp
print(eval(exp))

# (2차) => 나는 앞에 것만 확인 했는데 결과를 모아놓는 값(answer)도 0 or 1 인지도 함께 체크해야 함
s = input()
answer = int(s[0])

for i in range(1, len(s)):
    # 두 수 중 하나라도 0, 1인 경우, 더하기 수행
    if int(s[i]) <= 1 or answer <= 1:
        answer += int(s[i])
    else:
        answer *= int(s[i])
print(answer)


# 한 마을에 모험가가 N명 있습니다.
# 모험가 길드에서는 N명의 모험가를 대상으로 '공포도'를 측정했는데,'공포도'가 높은 모험가는 쉽게 공포를 느껴 위험 상황에서 제대로 대처할 능력이 떨어집니다.
# 모험가 길드장인 동빈이는 모험가 그룹을 안전하게 구성하고자 공포도가 X인 모험가는 반드시 X명 이상으로구성한 모험가 그룹에 참여해야 여행을 떠날 수 있도록 규정했습니다.
# 동빈이는 최대 몇 개의 모험가 그룹을 만들 수 있는지 궁금합니다.
# N명의 모험가에 대한 정보가 주어졌을 때, 여행을 떠날 수 있는 그룹 수의 최댓값을 구하는 프로그램을 작성하세요.
# 예를 들어, N = 5이고, 각 모험가의 공포도가 다음과 같다고 가정합시다.
# 2 3 1 2 2
# 이 경우 그룹 1에 공포도가 1,2,3인 모험가를 한 명씩 넣고, 그룹 2에 공포도가 2인 남은 두 명을 넣게 되면 총 2개의 그룹을 만들 수 있습니다.
# 또한 몇 명의 모험가는 마을에 그대로 남아 있어도 되기 때문에, 모든 모험가를 특정한 그룹에 넣을 필요는 없습니다.

# 시간 제한: 1초
# 메모리 제한: 128MB

# [입력]
# 첫째 줄에 모험가의 수 N이 주어집니다.(1<=N<=100,000)
# 둘째 줄에 각 모험가의 공포도의 값을 N 이하의 자연수로 주어지며, 각 자연수는 공백으로 구분합니다.

# [출력]
# 여행을 떠날 수 있는 그룹 수의 최댓값을 출력합니다.

# (1차) 해설 안보고 혼자 풀기
n = int(input())
m = sorted(list(map(int, input().split())))

group = []
count = 0
for i in m:
    group.append(i)
    if len(group) >= i:
        count += 1
        group.clear()

print(count)

