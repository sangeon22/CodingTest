# 그리디 알고리즘(탐욕법)
# 지금 당장 좋은 것만 고르는 것
# 단순히 가장 좋아 보이는 것을 반복적으로 선택해도 최적의 해를 구할 수 있는지 검토
# 일반적인 상황에서 그리디는 최적의 해를 보장할 수 없을 때가 많음
# ex) 거스름돈 문제 => 가장 큰 단위부터 거슬러주면 됨
# 가장 큰 단위부터 거슬러 주는 것이 최적의 해를 보장하는 이유는?
# => 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문
n =1260
count = 0
arr = [500, 100, 50, 10]

for i in arr:
    count += n // i
    n %= i
print(count)

# 시간 복잡도는 O(N) => 동전의 단위 갯수로만 반복문을 돔 =>
# 동전의 총 종류에만 영향


# 어떠한 수 N이 1이 될 때 까지 다음의 두 과정 중 하나를 반복적으로 선택해 수행하려 함
# 단, 두번째 연산은 N이 K로 나누어 떨어질 때만 선택할 수 있음
# 1. N에서 1을 뺀다.
# 2. N을 K로 나눈다.
# N이 1이 될 때 까지 1번 혹은 2번의 과정을 수행해야하는 최소 횟수를 구하는 프로그램을 작성
#
# 시간 제한: 2초
#
# [입력]
# 첫째 줄에 N(2<= N <= 100000)과 K(2 <= K <= 100000)가 공백으로 구분되며 각각 자연수로 주어짐
# 이때, 입력으로 주어지는 N은 항상 K보다 크거나 같음
#
# [출력]
# 첫째 줄에 N이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야 하는 횟수의 최솟값을 출력
#
# [입력 예시]
# 3 3
# 3 1 2
# 4 1 4
# 2 2 2

# 가능하면 최대한 많이 나눈다 => 최적의 해 보장? => 1빼는 것보다 K로 나누는게 가장 빠르게 N을 줄일 수 있고, 2가지 방법을 통해 항상 1이 된다.

# (1차) => 이렇게 되면 나눠질 때까지 반복
N, K = map(int, input().split())
answer = 0
while True:
    if N % K == 0:
        N //= K
    else:
        N -= 1
    answer += 1

    if N == 1:
        break
print(answer)

# (2차) log 시간 복잡도로 해결 가능
N, K = map(int, input().split())
answer = 0
while True:
    target = (N // K) * K
    answer += (N - target)
    N = target

    if N < K:
        break

    N //= K
    answer += 1
answer += (N - 1)
print(answer)



